I am building a project called H.I.V.E. (Heuristic Intelligence & Virtual 
Entrapment) - an AI-powered scam honeypot API system for a national hackathon.

=== TECH STACK ===
- Python 3.11+
- FastAPI + Uvicorn
- Google Gemini API (google-generativeai library)
  Model to use: gemini-2.0-flash (fast and cheap)
- python-dotenv
- No database (use in-memory Python dict for now)
- Pydantic for request/response models

=== PROJECT STRUCTURE TO CREATE ===

hive-honeypot/
├── app/
│   ├── __init__.py
│   ├── main.py
│   └── core/
│       ├── __init__.py
│       ├── scam_detector.py
│       ├── persona_manager.py
│       └── intelligence_extractor.py
├── .env
├── requirements.txt
└── test_segment1.py

=== .env FILE (create this) ===
GEMINI_API_KEY=your_gemini_api_key_here
API_KEY=hive-secret-key-2025

=== requirements.txt (create this) ===
fastapi
uvicorn
python-dotenv
google-generativeai
requests
pydantic

=== GEMINI SETUP PATTERN ===
Use this exact pattern for all Gemini calls throughout the project:

import google.generativeai as genai
import os

genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
model = genai.GenerativeModel("gemini-2.0-flash")

response = model.generate_content(your_prompt_here)
result = response.text

=== WHAT TO BUILD IN SEGMENT 1 ===

Build THREE core modules. Each module must also be exposed
as its own test API endpoint in main.py so I can verify
each one works independently using Postman or curl.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
MODULE 1: app/core/scam_detector.py
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Build a detect_scam(message: str) -> dict function.

LOGIC (two-step hybrid):

STEP 1 - Rule-based keyword detection (no LLM, instant):
  Check message for these keyword categories:
  
  urgency:   ["immediately", "urgent", "today", "right now", 
               "blocked", "suspended", "expire", "24 hours"]
  
  authority: ["bank", "rbi", "police", "government", 
               "income tax", "electricity board", "trai",
               "customer care", "helpdesk"]
  
  payment:   ["upi", "paytm", "gpay", "phonepe", "send money",
               "transfer", "pay now", "account number", "ifsc",
               "neft", "imps"]
  
  threat:    ["legal action", "arrest", "case filed", "penalty",
               "fine", "cut", "disconnected", "warrant"]
  
  phishing:  ["otp", "pin", "password", "verify", "kyc", 
               "update", "click", "download", "link", "login"]

  Calculate confidence score:
  - Count total keyword matches across all categories
  - confidence = min(total_matches / 5.0, 1.0)
  - If confidence >= 0.5 → return scam detected immediately (skip LLM)
  - If confidence >= 0.2 → go to Step 2 (uncertain, use LLM)
  - If confidence < 0.2  → return not a scam (skip LLM)

STEP 2 - Gemini LLM detection (only for uncertain cases):
  Send this prompt to Gemini:
  
  "Analyze if this message is a scam/fraud attempt targeting 
   Indian users. Message: '{message}'
   
   Look for: urgency tactics, authority impersonation (bank/police/
   government), payment requests (UPI/bank transfer), threats 
   (account blocked/legal action), phishing (OTP/KYC/password).
   
   Respond ONLY in this exact JSON format with no extra text:
   {
     'is_scam': true/false,
     'confidence': 0.0 to 1.0,
     'scam_type': 'bank_fraud/upi_fraud/phishing/lottery/job_scam/other/none',
     'reasoning': 'one line explanation'
   }"
  
  Parse the JSON response and return it.

HELPER FUNCTION - determine_scam_type(matched_categories: dict) -> str:
  - if "payment" and "authority" both matched → "bank_fraud"
  - if "payment" matched → "upi_fraud"  
  - if "phishing" matched → "phishing"
  - if "threat" matched → "threat_scam"
  - else → "general_scam"

FINAL RETURN FORMAT for detect_scam():
{
  "is_scam": true/false,
  "confidence": 0.0-1.0,
  "scam_type": "bank_fraud/upi_fraud/phishing/etc",
  "reasoning": "explanation string",
  "method": "rule_based or llm_based"
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
MODULE 2: app/core/persona_manager.py
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Build a PERSONAS dictionary and two functions.

PERSONAS dictionary - create these 5 personas:

"bank_fraud": {
  "name": "Ramesh (Panicked Elder)",
  "age": 68,
  "occupation": "Retired Government Employee",
  "tech_literacy": "very_low",
  "emotional_state": "panicked",
  "background": "68-year-old retired man from Chennai. Very 
    worried about pension account. Struggles with smartphones. 
    Has a dependent wife with health issues.",
  "speech_style": [
    "Use simple words and short sentences",
    "Show confusion with technology frequently",
    "Express worry and anxiety",
    "Occasionally use Tamil words: enna, seri, ayyo, appa",
    "Ask basic questions like what is this UPI?",
    "Make small mistakes in understanding instructions"
  ],
  "extraction_goals": [
    "Ask scammer to explain slowly to get more details",
    "Pretend to struggle with app to stall and get backup ID",
    "Ask for alternative payment methods",
    "Request scammer full name and number for bank records"
  ]
}

"upi_fraud": {
  "name": "Priya (Worried Housewife)",
  "age": 42,
  "occupation": "Housewife",
  "tech_literacy": "low",
  "emotional_state": "anxious",
  "background": "42-year-old housewife from Coimbatore. 
    Husband handles all finances. Home alone. Worried 
    about family bank account.",
  "speech_style": [
    "Mention husband is not home and you handle nothing",
    "Say you dont usually deal with financial things",
    "Ask to call back later then change subject",
    "Show increasing worry about consequences",
    "Request scammer to send details on WhatsApp for reference"
  ],
  "extraction_goals": [
    "Get scammer to send UPI ID in text form",
    "Ask for their direct phone number to call back",
    "Request supervisor number for verification",
    "Ask for official reference number and organization name"
  ]
}

"phishing": {
  "name": "Arjun (Gullible Student)",
  "age": 22,
  "occupation": "Engineering Student at VIT",
  "tech_literacy": "medium",
  "emotional_state": "nervous_but_curious",
  "background": "22-year-old engineering student. Recently 
    applied for many jobs and internships. Excited but 
    nervous about financial and official matters.",
  "speech_style": [
    "Sound enthusiastic and eager initially",
    "Ask many clarifying questions",
    "Say you need to verify before proceeding",
    "Mention needing to check with parents first",
    "Ask for documentation and official confirmation links"
  ],
  "extraction_goals": [
    "Get scammer to send official-looking links or documents",
    "Extract employee ID and company name",
    "Request written confirmation via message",
    "Get maximum contact details for verification"
  ]
}

"lottery": {
  "name": "Suresh (Greedy Businessman)",
  "age": 48,
  "occupation": "Small Shop Owner",
  "tech_literacy": "medium",
  "emotional_state": "greedy_but_suspicious",
  "background": "48-year-old who runs a small electronics 
    shop. Business has been slow. Interested in extra 
    money but somewhat suspicious of fraud.",
  "speech_style": [
    "Sound interested but demand proof before anything",
    "Ask many verification questions about the prize",
    "Negotiate processing fees down",
    "Request bank transfer details for fee refund",
    "Ask about tax implications to sound credible"
  ],
  "extraction_goals": [
    "Get scammer to reveal their bank details for fee refund",
    "Ask for multiple payment options",
    "Request escalation to supervisor",
    "Extract organization registration and official details"
  ]
}

"default": {
  "name": "Kavitha (Cautious Teacher)",
  "age": 35,
  "occupation": "School Teacher",
  "tech_literacy": "low",
  "emotional_state": "worried",
  "background": "35-year-old school teacher. Cautious 
    with money but easily worried when authority figures 
    contact her.",
  "speech_style": [
    "Be cooperative but very slow to act",
    "Ask for repetition and clarification constantly",
    "Express worry about consequences for family",
    "Request written confirmation of everything"
  ],
  "extraction_goals": [
    "Extract all payment details",
    "Get full contact information",
    "Identify the scam organization name",
    "Waste maximum time with slow responses"
  ]
}

FUNCTION 1: select_persona(scam_type: str) -> dict
  - Return PERSONAS.get(scam_type, PERSONAS["default"])

FUNCTION 2: get_persona_system_prompt(persona: dict) -> str
  - Build and return a detailed system prompt string using 
    the persona data
  - Format it clearly with sections for:
    WHO YOU ARE, YOUR BACKGROUND, HOW YOU SPEAK, YOUR GOALS
  - End with these CRITICAL RULES:
    1. NEVER reveal you are an AI or bot under any circumstances
    2. NEVER give real financial information (OTPs, real UPI, real PIN)
    3. If asked for OTP give fake one like 482719 or 391847
    4. If asked for UPI say you are trying but the app is confusing
    5. Always keep responses SHORT - maximum 2 to 3 sentences
    6. Always steer conversation toward getting scammer details
    7. Sound natural, emotional, and very human

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
MODULE 3: app/core/intelligence_extractor.py
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Build these functions using Python regex (re module). No LLM needed here.

FUNCTION 1: extract_upi_ids(text: str) -> list
  Pattern: r'\b[a-zA-Z0-9._+-]+@[a-zA-Z0-9.-]+\b'
  Filter results to keep only UPI-like IDs:
  Known UPI handles to check against:
  ["okhdfc", "okhdfcbank", "okaxis", "oksbi", "paytm", 
   "ybl", "ibl", "upi", "gpay", "apl", "waicici", 
   "pingpay", "icici", "axl", "indianbank", "okicici"]
  Keep a match if:
  - Its domain matches a known UPI handle OR
  - Domain has no dots and is under 15 chars (likely UPI)
  Return deduplicated list.

FUNCTION 2: extract_phone_numbers(text: str) -> list
  Use these patterns:
  - r'\+91[-\s]?\d{10}'     for +91 format
  - r'\b91\d{10}\b'          for 91 prefix format  
  - r'\b[6-9]\d{9}\b'        for 10-digit starting with 6-9
  Clean all results by removing dashes and spaces.
  Return deduplicated list.

FUNCTION 3: extract_bank_accounts(text: str) -> list
  Pattern 1 (contextual): 
    r'(?:account|a/c|ac|acct|savings|current)[\s:.-]*(\d{9,18})'
  Pattern 2 (standalone): 
    r'\b(\d{11,18})\b'
  Combine both results, deduplicate, return list.

FUNCTION 4: extract_phishing_links(text: str) -> list
  Pattern 1 (standard URLs): 
    r'https?://[^\s<>"{}|\\^`\[\]]+'
  Pattern 2 (short URLs): 
    r'\b(?:bit\.ly|tinyurl\.com|t\.co|goo\.gl|ow\.ly)/[^\s]+'
  Pattern 3 (suspicious domains): 
    r'\b(?:www\.)?[a-zA-Z0-9-]+(?:bank|sbi|hdfc|icici|verify|kyc|update)[a-zA-Z0-9-]*\.[a-zA-Z]{2,}\b'
  Combine all, deduplicate, return list.

FUNCTION 5: extract_suspicious_keywords(text: str) -> list
  Check for these keywords in lowercase message:
  ["urgent", "immediately", "verify", "blocked", "suspended",
   "otp", "pin", "password", "download", "click here",
   "kyc", "legal action", "arrested", "penalty", "account number"]
  Return list of keywords found.

FUNCTION 6: extract_all_intelligence(text: str) -> dict
  Call all 5 functions above and return:
  {
    "upiIds": [...],
    "phoneNumbers": [...],
    "bankAccounts": [...],
    "phishingLinks": [...],
    "suspiciousKeywords": [...]
  }

FUNCTION 7: merge_intelligence(existing: dict, new: dict) -> dict
  For each key in existing dict:
    Combine existing[key] + new[key] lists
    Remove duplicates using list(set(...))
  Return merged dict.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
MAIN.PY - TEST API ENDPOINTS FOR SEGMENT 1
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Create app/main.py with FastAPI. Add these TEST endpoints
so I can verify each module works independently:

ENDPOINT 1: POST /test/scam-detect
  Header required: x-api-key
  Request body:
  {
    "message": "Your bank account will be blocked today"
  }
  Response: full result from detect_scam(message)
  
ENDPOINT 2: POST /test/persona
  Header required: x-api-key
  Request body:
  {
    "scam_type": "bank_fraud"
  }
  Response:
  {
    "persona_name": "...",
    "persona_data": {...},
    "system_prompt": "..."
  }

ENDPOINT 3: POST /test/extract-intelligence
  Header required: x-api-key
  Request body:
  {
    "message": "Send money to scammer@okhdfc or call 9876543210"
  }
  Response: full result from extract_all_intelligence(message)

ENDPOINT 4: GET /health
  No auth needed
  Response: {"status": "HIVE is running", "segment": 1}

AUTH: All POST endpoints must check header x-api-key against
  API_KEY from .env. Return 401 if invalid.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
TEST FILE: test_segment1.py
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Create a test file that tests all 3 modules by calling 
the API endpoints above. Test with these messages:

Test 1 (should detect scam):
"Your bank account will be blocked today. Verify immediately."

Test 2 (should NOT detect scam):
"Hi, how are you doing today?"

Test 3 (should detect scam + extract UPI):
"Send Rs.10 to badguy@okhdfc immediately or face legal action"

Test 4 (should extract phone number):
"Call us back on 9876543210 to verify your KYC"

Test 5 (persona test):
Test all 5 scam types: bank_fraud, upi_fraud, phishing, lottery, default

Print clear PASS/FAIL for each test with the response received.

=== IMPORTANT INSTRUCTIONS FOR COPILOT ===
1. Create ALL files mentioned above
2. Add proper error handling with try/except in every function
3. Add clear comments explaining what each function does
4. Make sure all imports are correct
5. The Gemini JSON response may have markdown backticks - 
   handle that by stripping ```json and ``` before parsing
6. Run: pip install -r requirements.txt to install dependencies
7. Start server with: uvicorn app.main:app --reload --port 8000
8. Test with: python test_segment1.py


My H.I.V.E. project Segment 1 is complete and working.
Scam detection, persona manager, and intelligence extractor
are all tested and passing.

Now build Segment 2: Session Manager + Conversation Agent.

=== EXISTING STRUCTURE (already built) ===
app/
├── main.py               ← EXISTS, we will ADD endpoints to this
└── core/
    ├── scam_detector.py   ← EXISTS, do not touch
    ├── persona_manager.py ← EXISTS, do not touch
    └── intelligence_extractor.py ← EXISTS, do not touch

=== NEW FILES TO CREATE IN SEGMENT 2 ===
app/core/session_manager.py     ← NEW
app/core/conversation_agent.py  ← NEW
test_segment2.py                ← NEW test file

=== ADD TO requirements.txt ===
langgraph
langchain
langchain-google-genai

=== GEMINI SETUP REMINDER ===
Use google-generativeai library throughout:
import google.generativeai as genai
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
model = genai.GenerativeModel("gemini-2.0-flash")
response = model.generate_content(prompt)
result = response.text

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
MODULE 4: app/core/session_manager.py
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Use a simple in-memory Python dictionary called SESSIONS = {}
to store all session data. No Redis or database needed.

FUNCTION 1: get_or_create_session(session_id: str) -> dict
  If session_id not in SESSIONS, create new session:
  {
    "sessionId": session_id,
    "createdAt": current unix timestamp,
    "scamDetected": False,
    "scamType": None,
    "persona": None,
    "totalMessagesExchanged": 0,
    "conversationHistory": [],
    "extractedIntelligence": {
      "upiIds": [],
      "bankAccounts": [],
      "phoneNumbers": [],
      "phishingLinks": [],
      "suspiciousKeywords": []
    },
    "agentNotes": [],
    "callbackSent": False,
    "currentStage": "introduction"
  }
  Always return SESSIONS[session_id]

FUNCTION 2: update_session(session_id: str, updates: dict)
  Update SESSIONS[session_id] with the updates dict.
  Use dict.update() method.

FUNCTION 3: add_message(session_id: str, sender: str, 
                         text: str, timestamp: int)
  Append to conversationHistory:
  {"sender": sender, "text": text, "timestamp": timestamp}
  Increment totalMessagesExchanged by 1.

FUNCTION 4: update_stage(session_id: str)
  Based on totalMessagesExchanged, update currentStage:
  - 0 to 2 messages   → "introduction"
  - 3 to 6 messages   → "grooming"
  - 7 to 10 messages  → "the_ask"
  - 11+ messages      → "extraction_complete"
  Save updated stage to session.

FUNCTION 5: should_send_callback(session_id: str) -> bool
  Return True ONLY IF ALL of these are true:
  - session["scamDetected"] is True
  - session["callbackSent"] is False
  - At least ONE of these is non-empty:
    upiIds, phoneNumbers, or bankAccounts
    in extractedIntelligence
  - totalMessagesExchanged >= 5
  OR if totalMessagesExchanged >= 15 (force terminate)
  AND callbackSent is False

FUNCTION 6: get_session_summary(session_id: str) -> str
  Build a summary string from session data:
  - Scam type detected
  - List of extracted UPI IDs (or "none found")
  - List of extracted phone numbers (or "none found")
  - Total messages exchanged
  - Scam tactics observed (from suspiciousKeywords)
  Return as a readable single string.

FUNCTION 7: get_all_sessions() -> dict
  Return summary of all sessions:
  For each session return:
  {
    "sessionId": ...,
    "scamDetected": ...,
    "totalMessages": ...,
    "stage": ...,
    "callbackSent": ...,
    "intelFound": {
      "upiIds": count,
      "phoneNumbers": count
    }
  }

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
MODULE 5: app/core/conversation_agent.py
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Build a LangGraph-based conversation agent with 3 nodes.

IMPORTS NEEDED:
from langgraph.graph import StateGraph, END
from typing import TypedDict, List, Optional, Annotated
import google.generativeai as genai
from app.core.persona_manager import get_persona_system_prompt

STATE DEFINITION (TypedDict called AgentState):
{
  "session_id": str,
  "latest_message": str,
  "conversation_history": list,
  "persona": dict,
  "extracted_intel": dict,
  "current_stage": str,
  "strategy": str,
  "strategy_reason": str,
  "reply": str
}

─────────────────────────────────────────────────
NODE 1: profiler_node(state: AgentState) -> AgentState
─────────────────────────────────────────────────
This node analyzes the situation and sets the strategy.
It does NOT call Gemini. Pure logic only.

STRATEGY DECISION LOGIC:

Get intel from state["extracted_intel"]
Get stage from state["current_stage"]  
Get message from state["latest_message"].lower()

Check message for these trigger words:
  payment_words = ["upi", "send", "pay", "transfer", 
                   "account", "gpay", "phonepe", "paytm"]
  
  identity_words = ["name", "details", "address", 
                    "confirm", "verify", "your"]

STRATEGY SELECTION:
  
  if stage == "introduction":
    strategy = "show_fear_and_compliance"
    reason = "Build trust, appear as easy target"
  
  elif stage == "grooming":
    if any payment_word in message:
      strategy = "simulate_payment_failure"
      reason = "Force scammer to reveal backup payment method"
    else:
      strategy = "ask_clarifying_questions"  
      reason = "Extract more details about the operation"
  
  elif stage == "the_ask":
    if no upiIds AND no bankAccounts in intel:
      strategy = "feigned_incompetence"
      reason = "Pretend to try, fail, force scammer to simplify"
    elif no phoneNumbers in intel:
      strategy = "request_callback_number"
      reason = "Extract scammer phone number"
    else:
      strategy = "stall_for_backup_id"
      reason = "Already have primary ID, get backup payment ID"
  
  elif stage == "extraction_complete":
    strategy = "graceful_exit"
    reason = "Have enough intel, wind down naturally"
  
  else:
    strategy = "show_fear_and_compliance"
    reason = "Default cooperative strategy"

Update state with strategy and strategy_reason.
Return updated state.

─────────────────────────────────────────────────
NODE 2: strategist_node(state: AgentState) -> AgentState
─────────────────────────────────────────────────
This node translates strategy into specific instructions
for the actor. Pure logic, no Gemini call.

Build a strategy_instructions dict:

"show_fear_and_compliance":
  "Sound very worried and scared. Comply immediately. 
   Ask what exactly you need to do step by step. 
   Express that you cannot afford to lose your account."

"simulate_payment_failure":
  "Say you tried to pay but got an error message. 
   Ask if they have a different payment app like 
   Google Pay, PhonePe, or Paytm. Say HDFC server is down."

"ask_clarifying_questions":
  "Ask for more details: What is the reference number? 
   Who is their supervisor name? Which department are 
   they calling from? Ask slowly and write it down."

"feigned_incompetence":
  "Pretend you do not understand how to use the app. 
   Ask them to explain step by step very slowly. 
   Say the phone screen is confusing and hard to read."

"request_callback_number":
  "Say your phone battery is very low and might die soon. 
   Ask for their direct phone number so you can call 
   them back in 5 minutes after charging."

"stall_for_backup_id":
  "Say the payment is showing as processing but very slow. 
   Ask if there is another account or UPI you can send to 
   instead since this one keeps failing."

"graceful_exit":
  "Say you are trying your best but having technical trouble. 
   Keep asking small questions to stay in conversation. 
   Sound apologetic and slow."

Get the instruction for state["strategy"].
Update state with the instruction as strategy_reason.
Return updated state.

─────────────────────────────────────────────────
NODE 3: executor_node(state: AgentState) -> AgentState
─────────────────────────────────────────────────
This node calls Gemini to generate the actual reply.

STEP 1: Get persona system prompt:
  persona_prompt = get_persona_system_prompt(state["persona"])

STEP 2: Build conversation history string:
  Take LAST 6 messages from conversation_history only.
  Format each as:
  "Scammer: {text}" or "You: {text}"

STEP 3: Build the full prompt:

  f"""
  {persona_prompt}
  
  CURRENT INSTRUCTION: {state['strategy_reason']}
  
  RECENT CONVERSATION:
  {history_text}
  
  SCAMMER JUST SAID: "{state['latest_message']}"
  
  Write your reply as the victim character.
  
  STRICT RULES:
  - Maximum 2 sentences only
  - Sound emotional and human, not robotic
  - Follow the CURRENT INSTRUCTION above
  - Do NOT reveal you are AI
  - Do NOT give real bank/UPI/OTP details
  - Stay completely in character
  """

STEP 4: Call Gemini:
  response = model.generate_content(prompt)
  reply = response.text.strip()

STEP 5: Update state["reply"] = reply
Return updated state.

─────────────────────────────────────────────────
BUILD THE LANGGRAPH WORKFLOW
─────────────────────────────────────────────────

Function build_agent() -> compiled graph:
  workflow = StateGraph(AgentState)
  
  Add nodes:
  workflow.add_node("profiler", profiler_node)
  workflow.add_node("strategist", strategist_node)
  workflow.add_node("executor", executor_node)
  
  Set entry point: "profiler"
  
  Add edges:
  profiler → strategist
  strategist → executor
  executor → END
  
  Return workflow.compile()

Create agent instance at module level:
  agent = build_agent()

─────────────────────────────────────────────────
MAIN FUNCTION: run_agent(...)
─────────────────────────────────────────────────

def run_agent(
  session_id: str,
  latest_message: str,
  conversation_history: list,
  persona: dict,
  extracted_intel: dict,
  current_stage: str = "introduction"
) -> str:

  Build initial_state dict with all AgentState fields.
  Set strategy, strategy_reason, reply to empty strings.
  
  result = agent.invoke(initial_state)
  return result["reply"]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
ADD TO main.py - NEW TEST ENDPOINTS FOR SEGMENT 2
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Import new modules at top of main.py:
from app.core.session_manager import (
  get_or_create_session, update_session, add_message,
  update_stage, should_send_callback, get_session_summary,
  get_all_sessions
)
from app.core.conversation_agent import run_agent

ADD these new endpoints (keep existing endpoints from Segment 1):

ENDPOINT 5: POST /test/session-create
  Header: x-api-key
  Body: {"session_id": "test-001"}
  Creates session and returns the full session object.

ENDPOINT 6: GET /test/session/{session_id}
  Header: x-api-key  
  Returns full session data for that session_id.
  Return 404 if session not found.

ENDPOINT 7: GET /test/sessions/all
  Header: x-api-key
  Returns summary of all active sessions.

ENDPOINT 8: POST /test/agent-reply
  Header: x-api-key
  Body:
  {
    "session_id": "test-001",
    "scammer_message": "Send Rs.10 to badguy@okhdfc immediately",
    "scam_type": "bank_fraud",
    "stage": "grooming"
  }
  
  Logic:
  1. Get or create session
  2. Select persona using scam_type
  3. Extract intelligence from scammer_message
  4. Call run_agent() with all parameters
  5. Return:
  {
    "session_id": ...,
    "scammer_said": ...,
    "hive_reply": ...,
    "strategy_used": ...,
    "current_stage": ...,
    "intel_extracted_this_message": {...}
  }

ENDPOINT 9: POST /test/multi-turn
  Header: x-api-key
  Body: {"session_id": "test-mt-001"}
  
  Simulate a 5-message conversation automatically:
  
  messages = [
    "Your bank account will be blocked today. Verify immediately.",
    "Send Rs.10 to badguy@okhdfc to verify your account.",
    "Why are you taking time? Only 10 minutes left!",
    "Call 9876543210 for assistance. Send to backup: fraud@paytm",
    "Final warning. Legal action will be taken."
  ]
  
  For each message:
  - Detect scam
  - Extract intelligence
  - Add to session history
  - Run agent to get reply
  - Update session stage
  - Add reply to history
  
  Return full conversation log and final extracted intelligence.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
TEST FILE: test_segment2.py
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Create test_segment2.py that tests:

TEST 1: Session creation
  - Create session "seg2-test-001"
  - Verify all fields exist with correct defaults
  - Print PASS/FAIL

TEST 2: Single agent reply
  - Call /test/agent-reply with bank fraud message
  - Verify reply is non-empty string
  - Verify reply is under 200 characters (short)
  - Print the actual reply
  - Print PASS/FAIL

TEST 3: Multi-turn conversation
  - Call /test/multi-turn
  - Verify 5 exchanges happened
  - Verify intelligence was extracted
  - Print full conversation
  - Print PASS/FAIL

TEST 4: Strategy verification
  - Send payment-related message in grooming stage
  - Verify strategy is "simulate_payment_failure"
  - Print PASS/FAIL

TEST 5: Session persistence
  - Create session, add messages, retrieve session
  - Verify message count is correct
  - Print PASS/FAIL

=== IMPORTANT INSTRUCTIONS ===
1. Install new dependencies: pip install langgraph langchain langchain-google-genai
2. Do NOT modify any Segment 1 files
3. Add proper error handling everywhere
4. Test with: python test_segment2.py
5. Server must still run with: uvicorn app.main:app --reload --port 8000


H.I.V.E. Segments 1 and 2 are complete and tested.
Scam detection, personas, intelligence extraction,
session management, and conversation agent all work.

Now build Segment 3: the final production-ready API
that ties everything together.

=== EXISTING STRUCTURE (already built) ===
app/
├── main.py                      ← EXISTS, we REPLACE this
└── core/
    ├── scam_detector.py          ← EXISTS, do not touch
    ├── persona_manager.py        ← EXISTS, do not touch
    ├── intelligence_extractor.py ← EXISTS, do not touch
    ├── session_manager.py        ← EXISTS, do not touch
    └── conversation_agent.py     ← EXISTS, do not touch

=== NEW FILES TO CREATE IN SEGMENT 3 ===
app/core/callback_handler.py   ← NEW
app/main.py                    ← REPLACE existing main.py
test_segment3.py               ← NEW test file
test_full_flow.py              ← NEW complete integration test

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
MODULE 6: app/core/callback_handler.py
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

FUNCTION 1: send_final_callback(session: dict) -> bool

  GUVI_URL = "https://hackathon.guvi.in/api/updateHoneyPotFinalResult"
  
  Build agent_notes string:
    Join all items in session["agentNotes"] with " | "
    If empty, use: 
    f"Scam type: {session['scamType']}. 
      Extracted {len(session['extractedIntelligence']['upiIds'])} 
      UPI IDs and {len(session['extractedIntelligence']['phoneNumbers'])} 
      phone numbers over {session['totalMessagesExchanged']} messages."

  Build payload:
  {
    "sessionId": session["sessionId"],
    "scamDetected": session["scamDetected"],
    "totalMessagesExchanged": session["totalMessagesExchanged"],
    "extractedIntelligence": {
      "bankAccounts": session["extractedIntelligence"]["bankAccounts"],
      "upiIds": session["extractedIntelligence"]["upiIds"],
      "phishingLinks": session["extractedIntelligence"]["phishingLinks"],
      "phoneNumbers": session["extractedIntelligence"]["phoneNumbers"],
      "suspiciousKeywords": session["extractedIntelligence"]["suspiciousKeywords"]
    },
    "agentNotes": agent_notes
  }

  Send POST request to GUVI_URL:
  - timeout = 10 seconds
  - headers: Content-Type application/json
  
  Handle responses:
  - Status 200 → print success message, return True
  - Other status → print warning with status code and body, return False
  - Timeout exception → print timeout error, return False
  - Any other exception → print error message, return False

FUNCTION 2: build_agent_notes(session: dict) -> str
  Build a comprehensive summary string:
  
  Include:
  - "Scam Type: {scamType}"
  - "Total Messages: {totalMessagesExchanged}"
  - If upiIds found: "UPI IDs extracted: {joined list}"
  - If phoneNumbers found: "Phone numbers: {joined list}"
  - If phishingLinks found: "Phishing links: {joined list}"
  - If suspiciousKeywords: "Tactics used: {first 5 keywords joined}"
  - "Persona deployed: {persona name if exists}"
  
  Join all lines with " | "
  Return final string.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
FINAL app/main.py - COMPLETE REPLACEMENT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Replace main.py completely. Keep ALL segment 1 and 2 test 
endpoints AND add the production endpoint below.

IMPORTS:
from fastapi import FastAPI, Header, HTTPException, BackgroundTasks
from pydantic import BaseModel
from typing import List, Optional
import os
import time
from dotenv import load_dotenv

load_dotenv()

Import ALL modules:
from app.core.scam_detector import detect_scam
from app.core.persona_manager import select_persona
from app.core.conversation_agent import run_agent
from app.core.intelligence_extractor import (
  extract_all_intelligence, merge_intelligence
)
from app.core.session_manager import (
  get_or_create_session, update_session, add_message,
  update_stage, should_send_callback, 
  get_session_summary, get_all_sessions
)
from app.core.callback_handler import (
  send_final_callback, build_agent_notes
)

REQUEST MODELS (Pydantic):

class IncomingMessage(BaseModel):
  sender: str
  text: str
  timestamp: int

class HoneypotRequest(BaseModel):
  sessionId: str
  message: IncomingMessage
  conversationHistory: List[IncomingMessage] = []
  metadata: Optional[dict] = None

class ScamDetectRequest(BaseModel):
  message: str

class PersonaRequest(BaseModel):
  scam_type: str

class ExtractRequest(BaseModel):
  message: str

class SessionCreateRequest(BaseModel):
  session_id: str

class AgentReplyRequest(BaseModel):
  session_id: str
  scammer_message: str
  scam_type: str = "bank_fraud"
  stage: str = "grooming"

class MultiTurnRequest(BaseModel):
  session_id: str

─────────────────────────────────────────────────────────
PRODUCTION ENDPOINT: POST /api/honeypot
─────────────────────────────────────────────────────────

This is the MAIN endpoint the hackathon platform will call.
It must handle the complete flow end-to-end.

COMPLETE STEP BY STEP LOGIC:

STEP 1 - Authenticate:
  Check x-api-key header matches API_KEY from .env
  Return 401 HTTPException if invalid

STEP 2 - Get or create session:
  session = get_or_create_session(request.sessionId)

STEP 3 - Scam Detection (only if not yet detected):
  If session["scamDetected"] is False:
    Run detect_scam(request.message.text)
    
    If NOT scam (is_scam == False):
      Add scammer message to history
      Return immediately:
      {"status": "success", "reply": "I'm sorry, I don't understand. Can you clarify?"}
    
    If IS scam:
      Update session:
        scamDetected = True
        scamType = detection result scam_type
        persona = select_persona(detection scam_type)
      Add to session agentNotes:
        f"Scam detected: {scam_type} with confidence {confidence}"
  
  If session["scamDetected"] is already True:
    Skip detection, continue with existing persona

STEP 4 - Extract intelligence from latest message:
  new_intel = extract_all_intelligence(request.message.text)
  merged = merge_intelligence(
    session["extractedIntelligence"], 
    new_intel
  )
  update_session(request.sessionId, {"extractedIntelligence": merged})
  
  If any new UPI IDs or phone numbers found, add to agentNotes:
    f"Extracted: {new_intel}"

STEP 5 - Add scammer message to history:
  add_message(
    request.sessionId,
    request.message.sender,
    request.message.text,
    request.message.timestamp
  )

STEP 6 - Update conversation stage:
  update_stage(request.sessionId)
  Refresh session = get_or_create_session(request.sessionId)

STEP 7 - Generate agent reply:
  reply = run_agent(
    session_id = request.sessionId,
    latest_message = request.message.text,
    conversation_history = session["conversationHistory"],
    persona = session["persona"],
    extracted_intel = session["extractedIntelligence"],
    current_stage = session["currentStage"]
  )

STEP 8 - Add agent reply to history:
  add_message(
    request.sessionId,
    "user",
    reply,
    int(time.time() * 1000)
  )

STEP 9 - Check if should send callback:
  Refresh session = get_or_create_session(request.sessionId)
  
  If should_send_callback(request.sessionId) is True:
    Build and add final agent notes to session
    Use background_tasks.add_task() to send callback 
    WITHOUT blocking the API response
    Mark session callbackSent = True immediately
    (before callback actually completes)

STEP 10 - Return response:
  return {
    "status": "success",
    "reply": reply
  }

IMPORTANT: The endpoint must also accept BackgroundTasks 
as a parameter for async callback sending.

─────────────────────────────────────────────────────────
KEEP ALL SEGMENT 1 AND 2 TEST ENDPOINTS
─────────────────────────────────────────────────────────
Keep these working exactly as before:
- POST /test/scam-detect
- POST /test/persona
- POST /test/extract-intelligence
- GET  /health
- POST /test/session-create
- GET  /test/session/{session_id}
- GET  /test/sessions/all
- POST /test/agent-reply
- POST /test/multi-turn

UPDATE /health endpoint:
  Return:
  {
    "status": "HIVE is running",
    "version": "1.0.0",
    "segment": 3,
    "endpoints": {
      "production": "/api/honeypot",
      "test_scam": "/test/scam-detect",
      "test_persona": "/test/persona",
      "test_extract": "/test/extract-intelligence",
      "test_agent": "/test/agent-reply",
      "test_multi": "/test/multi-turn",
      "sessions": "/test/sessions/all"
    }
  }

─────────────────────────────────────────────────────────
ADD NEW TEST ENDPOINT: POST /test/callback-dry-run
─────────────────────────────────────────────────────────
Header: x-api-key
Body: {"session_id": "test-callback-001"}

Logic:
- Create a fake session with dummy data:
  scamDetected = True
  scamType = "bank_fraud"
  totalMessagesExchanged = 8
  extractedIntelligence:
    upiIds = ["test@okhdfc"]
    phoneNumbers = ["9876543210"]
    bankAccounts = []
    phishingLinks = []
    suspiciousKeywords = ["urgent", "blocked", "verify"]
  agentNotes = ["Test callback dry run"]

- Call send_final_callback(fake_session)
- Return:
  {
    "callback_attempted": true,
    "payload_sent": {the payload that was sent},
    "callback_success": true/false
  }

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
TEST FILE: test_segment3.py
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

TEST 1: Production endpoint - first message
  Send:
  {
    "sessionId": "seg3-test-001",
    "message": {
      "sender": "scammer",
      "text": "Your bank account will be blocked today. Verify immediately.",
      "timestamp": current_timestamp
    },
    "conversationHistory": [],
    "metadata": {"channel": "SMS", "language": "English", "locale": "IN"}
  }
  
  Verify:
  - Response has "status": "success"
  - Response has "reply" that is non-empty
  - Print PASS/FAIL

TEST 2: Production endpoint - follow up message
  Send second message to same session:
  {
    "sessionId": "seg3-test-001",
    "message": {
      "sender": "scammer",
      "text": "Send Rs.10 to scammer@okhdfc to verify account.",
      "timestamp": current_timestamp
    },
    "conversationHistory": [previous messages array],
    ...
  }
  
  Verify:
  - Gets a reply
  - Session has updated intelligence
  - Print session state after this message
  - Print PASS/FAIL

TEST 3: Callback dry run
  Call /test/callback-dry-run
  Print what payload was sent to GUVI
  Print PASS/FAIL based on whether callback attempt was made

TEST 4: Non-scam message
  Send "Hi how are you today?" to production endpoint
  Verify reply is generic (not scam-specific)
  Print PASS/FAIL

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
TEST FILE: test_full_flow.py  
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Simulate the EXACT flow the GUVI platform will use:

SESSION_ID = "guvi-simulation-001"
BASE_URL = "http://localhost:8000"

CONVERSATION_SCRIPT = [
  {
    "sender": "scammer",
    "text": "Your bank account will be blocked today. Verify immediately."
  },
  {
    "sender": "scammer", 
    "text": "Share your UPI ID to avoid account suspension."
  },
  {
    "sender": "scammer",
    "text": "You have 5 minutes. Send Rs.10 to badguy@okhdfc now."
  },
  {
    "sender": "scammer",
    "text": "Why no response? Call 9876543210 immediately."
  },
  {
    "sender": "scammer",
    "text": "Last warning. Legal action in 10 minutes. Try fraud@paytm also."
  },
  {
    "sender": "scammer",
    "text": "Download this app: http://fakebank-kyc.com/verify"
  }
]

For each message in script:
  1. Build request payload with full conversationHistory
     (accumulate history as you go)
  2. POST to /api/honeypot
  3. Print:
     "--- Message {n} ---"
     "Scammer: {message text}"
     "H.I.V.E.: {reply}"
  4. Add both messages to local history
  5. Wait 0.5 seconds between messages (simulate real conversation)

After all messages:
  GET /test/session/{SESSION_ID}
  Print final session state:
  - Total messages exchanged
  - All extracted intelligence
  - Current stage
  - Callback sent status

Final assertions:
  - At least 1 UPI ID extracted (badguy@okhdfc)
  - At least 1 phone number extracted (9876543210)  
  - At least 1 phishing link extracted
  - Callback was sent
  Print FINAL RESULT: PASS or FAIL

=== FINAL INSTRUCTIONS ===

1. After building, start server:
   uvicorn app.main:app --reload --port 8000

2. Run segment test first:
   python test_segment3.py

3. Run full integration test:
   python test_full_flow.py

4. Check all endpoints using /health for overview

5. The production endpoint /api/honeypot is what 
   you submit to GUVI as your API URL

6. Make sure your deployed URL is public before submission
   Use ngrok for demo: ngrok http 8000

7. GUVI will call your API like this:
   POST https://your-url/api/honeypot
   Header: x-api-key: hive-secret-key-2025
   Body: (the JSON format from problem statement)

YOUR FINAL SUBMISSION TO GUVI:
   API URL: https://your-deployed-url/api/honeypot
   API Key: hive-secret-key-2025 (or whatever you set in .env)